# 1

- 编码总结
  - 1.关于 root 与 子节点 \
  在BinarySearchTree中，从insert 方法可以看到，我在这里把root特殊对待了，对root单独做了判断，然后 对于子节点，才循环使用insert。但是在BinarySearchTreeVAL中可以看到，这种特殊对待是没有必要的。
  ```java
  //在入口函数中使用
  root = insert(x,root)
  // 那么 insert方法中的 null 值判断，也能够初始化root
  // 而实际上，我最初对待子节点的思路也是这样的，
  // 没有一开始就这样实现，原因： 1. 刚开始就满心欢喜的 注意到了预防root为空的情况
  //                           2. 对于这种循环结构不够熟悉
  ```
  - 2.关于按值传递与按引用传递的理解
    - 引用是个地址值 => 按引用传递 就是 地址值的按值传递 => 复制
  - 3.关于特例情况和通常情况的思考-在实现 BinarySearchTreeAVL中 旋转的方法的时候，我最初犯了一些错误，现在总结一下
    - 1.关于节点高度值的考虑不周全
      - 高度的维护最初没有一个好的思路，导致我在多处对高度进行了重复的维护，实际上在些这部分代码之前，我根本没有进行思考，只是跟着感觉走
      - 因为AVL树是在插入时调整的，调整必定伴随着高度变化。这里需要总结一个经验：`变化值在变化时调整，而不是在变化后调整` -> 使用balance函数对树结构进行调整，那么height也再balance中完成，这样是比较稳定的不会出现遗忘或重复的套路
    - 2.关于旋转函数的实现
      - 1.实际上我在处理这个问题的时候只考虑了最底层的旋转，也就是0/1/2三层的旋转。如果高度变的更高，我的思路实际上就除了问题
      - 2.总结注意实现：`要实现更普遍性的方法`。就像在rotate中，考虑所旋转的两个节点，拥有全部的叶子节点。然后在对叶子节点为null的情况，进行健壮性检查。
